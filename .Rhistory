Location
library(dplyr)
library(readxl)
# Define a function that checks for and creates a lookup vector, then cleans data
clean_data <- function(raw_value, excel_path = "path/to/Location_Lookup_Table.xlsx",
excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value") {
# Check if the lookup vector exists in the global environment; if not, create it
if (!exists("lookup_vector", envir = .GlobalEnv)) {
lookup_table <- read_excel(excel_path)
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
assign("lookup_vector", lookup_vector, envir = .GlobalEnv)
} else {
lookup_vector <- get("lookup_vector", envir = .GlobalEnv)
}
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Usage in a dplyr pipeline (assuming 'Location' is the dataframe and 'Raw Location Value' the column)
Location <- Location %>%
mutate(clean_location2 = clean_data(`Raw Location Value`))
Location
library(dplyr)
library(readxl)
# Define a function that checks for and creates a lookup vector, then cleans data
clean_data <- function(raw_value, excel_path = "Location_Lookup_Table.xlsx",
excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value") {
# Check if the lookup vector exists in the global environment; if not, create it
if (!exists("lookup_vector", envir = .GlobalEnv)) {
lookup_table <- read_excel(excel_path)
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
assign("lookup_vector", lookup_vector, envir = .GlobalEnv)
} else {
lookup_vector <- get("lookup_vector", envir = .GlobalEnv)
}
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Usage in a dplyr pipeline (assuming 'Location' is the dataframe and 'Raw Location Value' the column)
Location <- Location %>%
mutate(clean_location3 = clean_data(`Raw Location Value`))
Location
library(dplyr)
library(readxl)
# Define a function that checks for and creates a lookup vector, then cleans data
clean_data <- function(raw_value, excel_path = "Location_Lookup_Table.xlsx",
excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value") {
# Check if the lookup vector exists in the global environment; if not, create it
if (!exists("lookup_vector", envir = .GlobalEnv)) {
lookup_table <- read_excel(excel_path)
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
assign("lookup_vector", lookup_vector, envir = .GlobalEnv)
} else {
lookup_vector <- get("lookup_vector", envir = .GlobalEnv)
}
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Usage in a dplyr pipeline (assuming 'Location' is the dataframe and 'Raw Location Value' the column)
Location <- Location %>%
mutate(clean_location3 = clean_data(`Raw Location Value`))
Location <- read_excel("Location.xlsx")
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location2 = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location3 = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
Location <- read_excel("Location.xlsx")
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location3 = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
library(dplyr)
library(stringr)
# Define the function to clean the data, with an optional argument for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Convert to specified case
if (case == "lower") {
cleaned_text <- tolower(cleaned_text)
} else if (case == "upper") {
cleaned_text <- toupper(cleaned_text)
}
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello, world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
# Use mutate to clean the data
clean_data <- data %>%
mutate(clean_text = clean_character_data(raw_text, case = "upper"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data, with an optional argument for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Convert to specified case
if (case == "lower") {
cleaned_text <- tolower(cleaned_text)
} else if (case == "upper") {
cleaned_text <- toupper(cleaned_text)
}
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello,     world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
# Use mutate to clean the data
clean_data <- data %>%
mutate(clean_text = clean_character_data(raw_text, case = "upper"))
print(clean_data)
data <- tibble(
raw_text = c("Hello,     world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
data
data <- tibble(
raw_text = c("Hello,     world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew
line!")
)
data
library(dplyr)
library(stringr)
# Define the function to clean the data, with an optional argument for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Convert to specified case
if (case == "lower") {
cleaned_text <- tolower(cleaned_text)
} else if (case == "upper") {
cleaned_text <- toupper(cleaned_text)
}
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello,     world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew
line!")
)
# Use mutate to clean the data
clean_data <- data %>%
mutate(clean_text = clean_character_data(raw_text, case = "upper"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with extended options for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello, world!\n123", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
# Use mutate to clean the data with various case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with extended options for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello, world!\n123&^%&^$", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
# Use mutate to clean the data with various case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with extended options for text case
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text
data <- tibble(
raw_text = c("Hello,&^%&^% world!\n123&^%&^$", "Testing: 1, 2, 3.", "Clean? data!\nNew line!")
)
# Use mutate to clean the data with various case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with removal of all numbers and special characters
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters, including numbers, with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text and numbers
data <- tibble(
raw_text = c("Hello, world! 123", "Testing: 1, 2, 3.", "Clean? data! New line 456!")
)
# Use mutate to clean the data and apply different case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with removal of all numbers and special characters
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters, including numbers, with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text and numbers
data <- tibble(
raw_text = c("Hello, world! 123@#%@#^^", "Testing: 1, 2, 3.", "Clean? data! New line 456!")
)
# Use mutate to clean the data and apply different case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
library(dplyr)
library(stringr)
# Define the function to clean the data with removal of all numbers and special characters
clean_character_data <- function(text, case = "lower") {
# Replace non-letter and non-space characters, including numbers, with nothing
cleaned_text <- str_replace_all(text, "[^\\p{L}\\s]", "")
# Replace multiple spaces and line breaks with a single space
cleaned_text <- str_replace_all(cleaned_text, "\\s+", " ")
# Trim leading and trailing spaces
cleaned_text <- trimws(cleaned_text)
# Apply the specified case transformation
switch(case,
"lower" = cleaned_text <- tolower(cleaned_text),
"upper" = cleaned_text <- toupper(cleaned_text),
"title" = cleaned_text <- tools::toTitleCase(cleaned_text),
"sentence" = {
cleaned_text <- tolower(cleaned_text)
cleaned_text <- sub("^(.)", "\\U\\1", cleaned_text, perl = TRUE)
},
cleaned_text <- cleaned_text  # default to returning the cleaned text as is if no case match
)
return(cleaned_text)
}
# Example data frame with multi-line text and numbers
data <- tibble(
raw_text = c("Hello, world! 123@#%@#^^", "Testing: 1, 2, 3.", "Clean? data! New line 456!")
)
# Use mutate to clean the data and apply different case options
clean_data <- data %>%
mutate(clean_text_lower = clean_character_data(raw_text, case = "lower"),
clean_text_upper = clean_character_data(raw_text, case = "upper"),
clean_text_title = clean_character_data(raw_text, case = "title"),
clean_text_sentence = clean_character_data(raw_text, case = "sentence"))
print(clean_data)
Location <- read_excel("Location.xlsx")
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location3 = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
library(dplyr)
library(readxl)
# Define a function that always creates a lookup vector and cleans data
# Allows specifying the sheet of the Excel file; defaults to the first sheet if not specified
clean_data <- function(raw_value, excel_path, excel_raw_col = "Raw Location Value", excel_clean_col = "Clean Location Value", sheet = NULL) {
# Load the lookup table from the specified or first sheet
if (is.null(sheet)) {
lookup_table <- read_excel(excel_path)
} else {
lookup_table <- read_excel(excel_path, sheet = sheet)
}
# Create the lookup vector
lookup_vector <- setNames(lookup_table[[excel_clean_col]], lookup_table[[excel_raw_col]])
# Return the cleaned value or the original if not found
ifelse(is.na(lookup_vector[raw_value]), raw_value, lookup_vector[raw_value])
}
# Example usage:
# Assuming 'Location' is your dataframe and 'Raw Location Value' is the column to clean
# Specify the path to the Excel file, sheet, and relevant columns
Location <- Location %>%
mutate(clean_location = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx"),
clean_location3 = clean_data(`Raw Location Value`, "Location_Lookup_Table.xlsx", sheet = 1))
Location
